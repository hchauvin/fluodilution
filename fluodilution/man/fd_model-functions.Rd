% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/fd_model.R
\name{fd_model-functions}
\alias{fd_model-functions}
\alias{fd_formula}
\alias{start.fd_model}
\alias{lower}
\alias{lower.fd_model}
\alias{upper}
\alias{upper.fd_model}
\alias{relist.fd_model}
\alias{fd_freepar}
\title{Miscellaneous functions for the optimization of an FD model.}
\usage{
fd_formula(globalname, mgen = NULL)

\method{start}{fd_model}(x, free = TRUE, ...)

lower(x, ...)

\method{lower}{fd_model}(x, free = TRUE, ...)

upper(x, ...)

\method{upper}{fd_model}(x, free = TRUE, ...)

\method{relist}{fd_model}(flesh, skeleton)

fd_freepar(structured, x)
}
\arguments{
\item{globalname}{The name of an \code{\link{fd_model}} object sitting in the
global environment (that is, a \code{\link{character}} object).  See below
for the rationale.}

\item{mgen}{Maximum number of generations (if \code{NULL}, the default of the
proliferation model is taken).}

\item{x}{An \code{\link{fd_model}} object.}

\item{free}{Should the starting, lower or upper values returned by
\code{start}, \code{lower} and \code{upper} be given only for the free
parameters (in this case a named vector is returned) or for all the
parameters, including the constrained ones (in this case a list is
returned)?}

\item{...}{Not used.}

\item{flesh}{A named vector of free parameters, such as returned by
\code{start(skeleton)}.}

\item{skeleton}{An \code{\link{fd_model}} object.}

\item{structured}{An unconstrained, transformed and structured list of
parameters (e.g., as returned by \code{relist}).}
}
\value{
\code{fd_formula} builds a formula suitable for using with
\code{\link[stats]{nls}}, \code{\link[nlme]{nlsList}},
\code{\link[nlme]{nlme}} or \code{\link[nlme]{gnls}}. \code{start} returns
the default starting parameters for the FD model, either as a named vector of
free parameters (the default) or an unconstrained, transformed and structured
list of parameters.  \code{lower} and \code{upper} are two new generic
functions, aligned with the way \code{start} is defined in the
\code{\link{stats}} package (originally with time-series in mind), and for an
\code{fd_model} return the lower and upper bounds along the same modalities.
\code{relist} takes a named vector of free parameters \code{flesh} such as
the ones returned by \code{start}, \code{lower} and \code{upper} (when
\code{free=TRUE}) and turns them into an unconstrained, transformed and
structured list of parameters. \code{fd_freepar} performs the inverse
operations and from a the result of \code{relist} returns a named vector of
free parameters.
}
\description{
These functions can be used when calling nonlinear optimization
  functions such as \code{\link[stats]{nls}}, \code{\link[nlme]{nlsList}},
  \code{\link[nlme]{nlme}} or \code{\link[nlme]{gnls}} (alternatively, the
  wrapper \code{\link{fd_nls}} can be used).
}
\section{Why a "global name" instead of a regular object}{


  Because \code{\link[stats]{nls}}-like functions and
  \code{\link[nlme]{nlme}} use different scoping rules, great care must be
  exercised concerning the scoping of the functions called in a formula.
  Indeed, for \code{nls}, the functions are first looked at in the
  environment of the formula, then in the \code{data} parameter if it is a
  list or an environment, and finally in the global environment.  For
  \code{nlme}, however, the scope is \emph{always} the global environment
  (Lumley 2003) and \code{data} can only be a \code{data.frame} for obvious
  reasons (it is cut down in many pieces according to the various levels of
  grouping).  In the end, to stress this point, we decided that not an
  \code{fd_model} object should be passed along to \code{formula} but the
  \emph{name} of an \code{fd_model} (that is, a \code{\link{character}}
  object) sitting in the global environment.  This implementation, of course,
  has many drawbacks, including the mandatory use of global variables, but it
  seems to be the only sensible one when using such complex nonlinear models
  within the formula paradigm.  To avoid such a contortion, general
  likelihood optimizers such as \code{\link[stats4]{mle}} or
  \code{\link[bbmle]{mle2}} could well be used instead of \code{nls} (see
  \code{\link{fd_minuslogl}}).  Unfortunately, no such alternative exists for
  either \code{\link[nlme]{nlme}} or \code{\link[nlme]{gnls}}.
}

\examples{
data(FdSTyphimuriumWTC57)
dat <- cutoff(FdSTyphimuriumWTC57)
mdl <<- fd_model(data=dat, constraints=attr(dat, "bestcstr"))

rbind(start = unlist(relist(start(mdl), mdl)),
      lower = unlist(relist(lower(mdl), mdl)),
      upper = unlist(relist(upper(mdl), mdl)))

# fd_formula can be fed directly to, e.g., nls
# (alternatively, fd_nls can be used: it is essentially a wrapper
# around nls with additional checks and an automatic, albeit far from
# perfect, determination of mgen)
fd_formula("mdl")

control <- list(maxit = 1L)
\dontrun{
control <- NULL
}

# Let's use the "port" algorithm of 'nls'
\dontrun{
fit <- nls(fd_formula("mdl"), data = FdSTyphimuriumWTC57,
           algorithm="port", start=start(mdl),
           lower=lower(mdl), upper=upper(mdl),
           control=control)
# Error in nls(fd_formula("mdl"), data = FdSTyphimuriumWTC57,
# algorithm = "port",  :
#     Convergence failure: iteration limit reached without convergence (10)
}

# As it is likely to fail, we can use the global search
# algorithm 'GenSA' as well, again in an 'nls'-like framework
source(system.file("contrib", "nlsSA.R", package="fluodilution"))
fit <- nlsSA(fd_formula("mdl"), data = FdSTyphimuriumWTC57,
             start=start(mdl),
             lower=lower(mdl), upper=upper(mdl),
             control=control)

# A third option is to use fd_minuslogl, see the relevant
# page for an example.

}
\references{
Lumley T (2003).  \emph{Standard nonstandard evaluation rules.}
\url{http://developer.r-project.org/nonstandard-eval.pdf}
}
