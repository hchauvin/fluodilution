% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/fd_model.R
\name{fd_model}
\alias{fd_model}
\alias{fd_clean}
\alias{fd_clone}
\alias{update.fd_model}
\title{Create and maintain a fluorescence dilution (FD) model.}
\usage{
fd_model(fmm = "gaussian", proliferation = "branching", data = NULL,
  constraints = NULL, partial = NULL, boxed = TRUE,
  process = "fd_process_default", memoise = TRUE)

fd_clean(object)

fd_clone(object, clean = TRUE)

\method{update}{fd_model}(object, data = NULL, fmm, proliferation, addcstr,
  start, partial, boxed, process, ...)
}
\arguments{
\item{fmm}{A Finite Mixture Model (FMM), see \code{\link{finite-mixture}}.}

\item{proliferation}{A proliferation model, see \code{\link{proliferation}}.}

\item{data}{An optional \code{\link{fd_data}} used to construct the FMM and
the proliferation model.  If not specified, default values are used.}

\item{constraints}{A \code{cstr} object, as produced by
\code{\link{cstrlist}} or an \code{expression} if only the
\code{constraint} component is set (see \code{\link{constraints}}).}

\item{partial}{A numeric vector giving the index (not the name) of the
categories in the dataset to consider for fitting.  By default, all the
categories are considered.  Currently, the categories can only be
contiguous and include \code{1} (e.g., \code{1:3} but not \code{2L:3L}).
\code{partial} helps to shave off some computation time.}

\item{boxed}{Whether the parameters of the model should be boxed by upper and
lower bounds (\code{TRUE}) or "unboxed" by an \code{atanh} transformation
so as to be used with optimization methods that do not allow the
specification of a boundary (such as the default algorithm of
\code{\link[stats]{nls}}).  However, if the likely optimal parameters are
far from the boundary, \code{boxed=TRUE} can in general be used (for
example with \code{\link[nlme]{nlme}}).}

\item{process}{A function that is used internally by
\code{\link{fd_predict}}.  For advanced use, the default
\code{fd_process_default} can be overridden to accommodate for, e.g.,
"weights" other than fluorescence histograms and cell counts (see source
code of \verb{
}\code{fd_process_default}, exported but not documented, for
format).}

\item{memoise}{Whether the Finite Mixture Model stage should be memoised with
package \pkg{memoise}.  Memoisation drastically improves performance but
should probably be turned off, out of memory concerns, when optimizing
autofluorescence level and specific number of molecules with FMMs
\code{\link{fd_fmm_af}} and \code{\link{fd_fmm_af_bp}}.}

\item{object}{An \code{fd_model} object.}

\item{clean}{Whether \code{fd_clean} should be called as well.}

\item{addcstr}{Additional constraints to be added (using
\code{\link{catcstr}}) to the current set of constraints.  Either a
\code{\link{cstrlist}} or an \code{expression} if only the
\code{constraint} component is to be updated.}

\item{start}{Numeric vector.  Overrides the starting parameters available
  through\verb{
}\code{\link{start}(object)}.}

\item{...}{Not used.}
}
\value{
\code{fd_model} returns an \code{fd_model} object (an
  \code{\link[base]{environment}}). \code{fd_clean} modifies the model passed
  as a parameter and does not have a meaningful return value.
  \code{fd_clone}, on the other hand, returns a model that is not identical
  to the model passed along as argument.  \code{update} also returns a new
  environment.
}
\description{
These functions create and maintain a fluorescence dilution (FD) model,
linking together a Finite Mixture Model (FMM), a proliferation model and a
set of constraints.
}
\details{
\code{fd_model} creates a new fluorescence dilution, two-step
hierarchical model. This model can then be optimized with
\code{\link{fd_nls}}.  Predicting experimental values necessitate the
calculation of internal quantities that can be bulky in memory:
\code{fd_clean} provides for their removal.  Because models are environments,
copying them can only be done through \code{fd_clone}.  \code{update} updates
an existing model by changing some of its arguments.
}
\section{From full parameter list to vector of free parameters}{
 The
  parametrization of an FD model can be conveniently made with nested lists
  (see \code{\link{constraints}}).  More specifically, the top-level list has
  two elements named \code{fmm} and \code{pro} (for the format of those two
  elements, see respectively \code{\link{finite-mixture}} and
  \code{\link{proliferation}}).  However, multidimensional optimization
  functions only take vectors as arguments (the "free" parameters).
  Therefore, for simple problems, the starting parameters and lower/upper
  bounds are \code{unlist}ed and passed as arguments and the model is
  evaluated using a \code{relist}ing.  Here, we needed to introduce further
  steps along the way.

  To anchor the discussion, we call the parametrization with which the model
  is eventually evaluated the "natural parametrization".  A first step away
  from this parametrization and towards the vector of free parameters
  involves reparametrizing some parameters to allow the specification of
  bounds independent from each other and rescaling to speed up convergence.
  In the case of the branching processes, because the proportions must sum to
  \code{1}, i.e. \code{p + res + d = 1}, with \code{p} the proportion of
  cells that divide, \code{res} the proportion of non-growers and \code{d}
  the proportion of cells that die or leave the compartment, we reparametrize
  \code{p} and \code{res} to \code{`p'` = p + res} and \code{`res'` = res /
  (p + res)}, allowing us to give the lower bounds \code{c(`p'` = 0, `res'` =
  0)} and upper bounds \code{c(`p'` = 1, `res'` = 1)}. Alternatively,
  Lagrange multipliers could have been used, but this leads to instability in
  such large nonlinear problems.

  From this reparametrized version, we go on to constraining with
  \code{\link{constraints}}.  Constraining allows to reduce the dimension of
  a problem that would be too complicated to solve, even using global search
  (the "curse" of dimensionality), and in any case likely to be
  overparametrized in practice (henceforth not identifiable in practice).

  The free parameters that are not constrained are then \code{unlist}ed, and
  it is this named vector that is given to optimizers and returned by
  \code{\link{start}}, \code{\link{lower}} and \code{\link{upper}}.

In short, the steps from the natural parametrization to free parameters are:
\preformatted{
Action                Object
--------------        --------------
                      (1) natural
transformation   ->   (2) reparametrized
constraining     ->   (3) constrained
unlisting        ->   (4) unlisted
}
and naturally when evaluating the model the reverse procedure is applied:
\preformatted{
Action                        Object
----------------------        --------------
                              (4) unlisted
relisting                ->   (3) constrained
expansion                ->   (2) reparametrized
inverse transformation   ->   (1) natural
}
}

\section{Warning}{

The user should check with \code{\link{lower}} and \code{\link{upper}}
that the boundary
suits their needs.  If they do not, the \code{constraints} argument
should be a
\code{\link{cstrlist}} object.
}

\examples{
# Create a new model with default values
mdl <- fd_model()
print(mdl)
print(summary(mdl))

# Original size
sum(sapply(ls(mdl), function (nm) object.size(mdl[[nm]])))
sim <- fd_simulate(fd_draw_unif(mdl), c(2, 6, 12))

# Do calculations
fd_minuslogl(mdl, sim, verbose=FALSE)()
sum(sapply(ls(mdl), function (nm) object.size(mdl[[nm]])))

# Clean up a bit
fd_clean(mdl)
# Reduced size
sum(sapply(ls(mdl), function (nm) object.size(mdl[[nm]])))

# Clone
mdl2 <- fd_clone(mdl)
identical(mdl, mdl2)  # FALSE

# Update model (updating clones as well)
mdl3 <- update(mdl2, proliferation="cyton")
print(mdl2$pro)
print(mdl3$pro)
identical(mdl2, mdl3)  # FALSE
}
\seealso{
\code{\link{fd_model-functions}} for functions to be used with an
  \code{fd_model} object, \code{\link{fd_simulate}} for simulating a
  population, \code{\link{fd_nls}} for fitting an FD model.
}
