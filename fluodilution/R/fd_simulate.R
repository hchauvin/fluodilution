# Copyright (c) 2015-2018 Hadrien Chauvin
#
# Permission is hereby granted, free of charge, to any person obtaining a copy
# of this software and associated documentation files (the "Software"), to deal
# in the Software without restriction, including without limitation the rights
# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
# copies of the Software, and to permit persons to whom the Software is
# furnished to do so, subject to the following conditions:
#
# The above copyright notice and this permission notice shall be included in all
# copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
# SOFTWARE.
#####################

#' Simulation of datasets.
#'
#' \code{fd_simulate} simulates an \code{\link{fd_data}} dataset.
#' \code{fd_proportions} gives the proportion of cells in a given number of
#' generations and other related metrics.
#'
#' @param params For \code{fd_simulate}, A named numeric vector of coefficients
#'   or a matrix with parameter names in columns as would be returned by
#'   \code{coef} applied to an \code{\link[nlme]{nlme}},
#'   \code{\link[nlme]{nlsList}}, \code{\link[stats]{nls}} or
#'   \code{\link{fd_nls}} object or the result of \code{\link{fd_unif}}. For
#'   \code{fd_proportion}, only a named numeric vector is allowed.
#' @param times A numeric vector of times, in hours, at which to simulate
#'   sampling.
#' @param mgen Maximum number of generations (if \code{NULL}, the default of the
#'   proliferation model is taken).
#' @param breaks The breakpoints to use when forming histograms.  If it is a
#'   single number, number of breaks to use.  If it is a numeric vector, it
#'   directly gives the breakpoints in linear fluorescence units.  It is not
#'   possible to specify different breakpoints for different timepoints.
#' @param range A two-element numeric vector giving respectively the lower and
#'   upper breakpoints, in linear fluorescence units, when \code{breaks} is a
#'   single numeric value.  If not explicitly specified, the range is taken to
#'   be
#' \verb{
#' }\code{exp(mean(m0) + mean(sd0) * 3) * c(1 / 2.0^(mgen + 4), 1)}.
#' @param noise A two-element numeric vector that gives the standard deviations
#'   of a white noise to be added respectively to histograms and cell counts,
#'   after FMM transformations apply (see \code{\link{fd_transform}}).
#' @param select What \code{Type} the resulting \code{\link{fd_data}} should
#'   feature.
#' @param model An \code{\link{fd_model}} object.  In the case of
#'   \code{fd_norm}, mandatory only if \code{mean} was not generated by
#'   \code{\link{fd_unif}}, \code{\link{fd_draw_unif}}, \code{\link{fd_nls}} or
#'   \code{\link{fd_comb}}.
#' @param mean If \code{params} is a matrix, whether to average the columns to
#'   give a single set of parameters (\code{TRUE}) or to generate a dataset for
#'   each row (\code{FALSE}), in which case the dataset contains multiple
#'   \code{Individual}, labelled following the row names or \code{indiv_<i>} if
#'   no row name was given.
#'
#' @return \code{fd_simulate} returns an \code{\link{fd_data}} dataset.
#' \code{fd_proportions} returns a list with the following elements: \itemize{
#' \item For branching processes: \describe{ \item{\code{live_pop}}{A named list
#' of matrices.  The element names are the categories, the rows the timepoints
#' (in the order of argument \code{times}) and the columns the number of
#' generations (the first column gives generation 0).  The entries give the
#' proportions of cells in a given number of generation at a given time and the
#' rows sum to one.} \item{\code{Ns}}{A matrix giving the number of currently
#' alive cells in each category (columns) for each timepoint (rows), relative to
#' the \code{initial} argument passed along to \verb{
#' }\code{\link{fd_proliferation_branching}}.} \item{\code{lost_pop}}{Same as
#' \code{live_pop} but with the lost population.} \item{\code{Ns_lost}}{Same as
#' \code{Ns} but with (cumulative) lost cells.} \item{\code{cum_influx}}{A named
#' list of matrices, following the format of \code{live_pop}. The entries give
#' the cumulative influxes of cells in a given number of generation at a given
#' time, relative to the \code{initial} argument passed along to
#' \code{\link{fd_proliferation_branching}}.} }
#' \item For Cyton models: same
#' format but \code{cum_influx} is not available. }
#'
#' @family simulation-related entries
#'
#' @name dataset-simulation
#' @examples
#' un <- fd_unif("gaussian", "branching", n=5)
#' times <- c(2, 4, 6, 12)
#' sim <- fd_simulate(un, times,
#'                    select=c("hists", "hists_lost", "Ns", "Ns_lost"))
#' unique(sim$Individual)
#' plot(sim, main="Simulation")
#'
#' fd_proportions(un, times)
#'
#' un2 <- fd_unif("gaussian", "cyton", n=5)
#' fd_proportions(un2, times)
NULL

#' @export
#' @rdname dataset-simulation
fd_simulate <- function (params, times, mgen=NULL, breaks=50, range=NULL,
                         noise=NULL,
                         select = c("hists", "Ns"), model = NULL,
                         mean = FALSE) {
  if (length(select) == 0 ||
    !all(select %in% c("hists", "hists_lost", "Ns", "Ns_lost")) ||
      any(duplicated(select)))
    stop("'select' has wrong format")

  pp <- process_params(params, model, mgen, mean)
  params <- pp$params
  model <- pp$model
  mgen <- pp$mgen

  categories <- model$pro$categories
  if (length(categories) == 0) stop("'categories' is NULL")

  data <- NULL
  if (any(c("hists", "hists_lost") %in% select)) {
    if (length(breaks) == 1) {
      if (is.null(range)) {
        m0 <- model$fmm$m0
        sd0 <- model$fmm$sd0
        if (is.null(m0) || is.null(sd0))
          stop("'m0' or 'sd0' not available from FMM and no ",
             "'range' specified")
        rangemax <- exp(mean(m0) + mean(sd0) * 3)
        range <- c(rangemax / 2.0 ^ (mgen + 4), rangemax)
      }
      breaks <- sinh(seq(asinh(range[1]), asinh(range[2]),
                 length.out = breaks))
    }

    data <- rbind(
      data,
      expand.grid(
        Time = times,
        Category = categories,
        Individual = rownames(params),
        a = 1L:(length(breaks) - 1),
        Type = select[select %in% c("hists", "hists_lost")],
        Weight = "hist",
        Inoculum = "inoc_1",
        y = 0
      )
    )
    data$b <- breaks[-1][data$a]
    data$a <- breaks[-length(breaks)][data$a]
    data$Timepoint <-
      with(data, interaction(Individual, Category, Time, Type))
  }
  if (any(c("Ns_lost", "Ns") %in% select)) {
    data <- rbind(data, expand.grid(
      Time = times,
      Category = categories,
      Individual = rownames(params),
      a = 0,
      b = 0,
      y = 0,
      Type = select[select %in% c("Ns", "Ns_lost")],
      Weight = "N",
      Inoculum = "none",
      Timepoint = "none"))
  }
  data <- groupedData(y ~ 1 | Individual, data)
  attr(data, ".was_cutoff") <- TRUE
  attr(data, "fmm") <- list(
    m0 = setNames(mean(model$fmm$m0), "inoc_1"),
    sd0 = setNames(mean(model$fmm$sd0), "inoc_1"),
    cctrans = model$fmm$cctrans,
    htrans = model$fmm$htrans
  )
  attr(data, "pro") <- model$pro
  data <- fd_data(data, categories = categories)

  mdl <- update(model, data)
  data$y <- fd_predict_mat(mdl)(as.data.frame(data),
               params[data$Individual, , drop=FALSE], mgen=mgen)

  if (!is.null(noise)) {
    if (!is.numeric(noise) || length(noise) != 2)
      stop("'noise': invalid format")
    data$y <- with(data, ifelse(Weight == "hist",
                  y + rnorm(length(y), 0, noise[1]),
                  y + rnorm(length(y), 0, noise[2])))
    data[data$Weight == "hist", ] <-
      plyr::ddply(
        data[data$Weight == "hist", ], "Timepoint",
        function (df) {
            df$y <- df$y / sum(df$y)
            df
        }
      )
  }

  structure(data, .model = fd_clone(mdl))
}

#' @rdname dataset-simulation
#' @export
fd_proportions <- function (params, times, mgen=NULL, model = NULL) {
  pp <- process_params(params, model, mgen)
  params <- pp$params
  model <- pp$model
  mgen <- pp$mgen

  model$pro$model(relist(params, model)$pro,
          times=times, mgen=mgen)
}

#' @name random-parameters
#'
#' @title Generate random parameters.
#'
#' @description Generate random parameters from an \code{\link{fd_model}} with
#'   either a uniform draw (\code{fd_draw_unif} or the shortcut \code{fd_unif})
#'   or distributed normally (\code{fd_norm}).
#'
#' @inheritParams fd_model
#' @param model An \code{\link{fd_model}} object.  In the case of
#'   \code{fd_norm}, mandatory only if \code{mean} was not generated by
#'   \code{fd_unif}/\code{fd_draw_unif}.
#' @param n Number of sets of parameters to draw.
#' @param coverage A number between \code{0} and \code{1} indicating how much of
#'   the lower bounds-upper bounds interval should be covered by the random
#'   draw: for example, a coverage of \code{0.8} means that the interval will be
#'   shrank symmetrically to 80\% of its size.  This avoids drawing too extreme
#'   values.
#' @param mean A named numeric vector of coefficients or a matrix with parameter
#'   names in columns as would be returned by \code{coef} applied to an
#'   \code{\link[nlme]{nlme}}, \code{\link[nlme]{nlsList}},
#'   \code{\link[stats]{nls}} or \code{\link{fd_nls}} object or the result of
#'   \code{\link{fd_unif}}.  If it is a matrix, the columns are simply averaged.
#' @param cv Coefficient of variation (equal across all coefficients) of the
#'   normal distribution from which to draw.
#'
#' @return A named numeric vector of free parameters (\code{n=1}) or a matrix
#'   (\code{n>1}), augmented by information about the model that can be queried
#'   with \code{\link{model}}.  Therefore, it is possible to use
#'   \code{\link{relisted_coef}} on the return value.
#' @family simulation-related entries
#'
#' @examples
#' (ans <- fd_unif("gaussian", "branching"))
#' fd_draw_unif(model(ans))
#' fd_norm(3, ans)
#'
#' @section Required packages: Please install \pkg{truncnorm} for \code{fd_norm}
NULL

#' @rdname random-parameters
#' @export
fd_draw_unif <- function (model, n = 1, coverage = 0.8) {
  co <- (upper(model) - lower(model)) * (1 - coverage) / 2.0
  ans <- t(replicate(n,
             runif(length(lower(model)),
               lower(model) + co,
               upper(model) - co)))
  colnames(ans) <- names(lower(model))
  rownames(ans) <- paste0("indiv_", 1:n)
  structure(ans, .model = model)
}


#' @rdname random-parameters
#' @export
fd_unif <- function (fmm = "gaussian", proliferation = "branching",
           constraints = NULL,
           n = 1, coverage = 0.8) {
  if (coverage < 0 || coverage > 1)
    stop("'coverage' must be between 0 and 1")
  model <- fd_model(fmm, proliferation,
            constraints = constraints,
            boxed=TRUE)
  fd_draw_unif(model, n, coverage)
}


#' @rdname random-parameters
#' @export
fd_norm <- function (n, mean, cv=0.1, model=NULL) {
  if (!requireNamespace("truncnorm", quietly=TRUE))
    stop("'fd_norm' requires package 'truncnorm'")
  pp <- process_params(mean, model, NULL)
  mean <- pp$params
  model <- pp$model
  if (cv < 0 || cv > 1)
    stop("'cv' must be between 0 and 1")
  ans <- t(replicate(n,
             fixed_rtruncnorm(length(lower(model)),
                  a=lower(model),
                  b=upper(model),
                  mean=drop(mean),
                  sd=drop(mean) * cv)))
  colnames(ans) <- names(lower(model))
  rownames(ans) <- paste0("indiv_", 1:n)
  structure(ans, mean = drop(mean), model = model, cv = cv)
}


# Internal ----------------------------------------------------------------

# Note: we cannot use truncnorm::rtruncnorm directly, as the .Call
# there to C implementation is broken (now, it needs a "package" parameter).
fixed_rtruncnorm <- function(n, a=-Inf, b=Inf, mean=0, sd=1) {
  if (length(n) > 1)
    n <- length(n)
  if (length(n) > 1)
    n <- length(n)
  else if (!is.numeric(n))
    stop("non-numeric argument n.")
  .Call("do_rtruncnorm", as.integer(n), a, b, mean, sd, PACKAGE = "truncnorm")
}

process_params <- function (params, model, mgen, mean=TRUE) {
  if (is.null(model))
    model <- match.fun("model")(params)
  if (is.null(model)) {
    stop("no model specified, either through 'params' or 'model'")
  }

  if (is.numeric(params) || is.matrix(params)) {
    if (is.vector(params)) params <- rbind("indiv_1" = params)
  } else if (!is.null(coef(params))) {
    tmp <- rbind(coef(params))
    if (is.null(rownames(tmp)))
      rownames(tmp) <- paste0("indiv_", 1:NROW(tmp))
    params <- tmp
  } else {
    stop("'params' must either be the result of a fit, ",
       "a vector or a matrix")
  }

  if (mean) {
    params <- rbind(colMeans(params))
    rownames(params) <- "indiv"
  }

  for (i in 1:NROW(params)) {
    if (any(params[i, ] < lower(model) | params[i, ] > upper(model)))
      stop("parameter \"", colnames(params)[i], "\" is out of bounds")
  }

  if (is.null(mgen)) mgen <- model$pro$mgen

  attr(params, ".model") <- NULL

  list(params = params, model = model, mgen = mgen)
}